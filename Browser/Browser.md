# Browser Architecture

- Reference

  - https://developers.google.com/web/resources/contributors/kosamari
  - https://d2.naver.com/helloworld/2922312
  - https://d2.naver.com/helloworld/59361

---

## Summary

1. 다중 프로세스 아키텍처(CPU, GPU, Memory)

- 장점
- 한계
- 서비스화

2. Navigation 과정(사용자가 사이트를 요청하고 브라우저가 페이지 렌더링을 준비)

- Chrome process & thread 동작 과정
- Navigation 속도 향상
  - ServiceWorker
  - Navigation preload

3. Renderer Process(HTML 문서를 받았을때)

- Renderer Process Architecture

4. User Input(Compositor)

- 웹 페이지 반응성 향상을 위해 사용자 입력을 어떻게 다루는지

---

## Chapter

1. CPU,GPU,메모리, 다중 프로세스 아키텍처
   - CPU
   - GPU
   - Process & Thread
   - Browser Architecture
   - Chrome의 각 Process
   - 다중 프로세스 아키텍처가 Chrome에 주는 이점
   - Chrome의 서비스화 - 메모리 절약
   - 사이트 격리 - 프레임별로 실행되는 렌더러 프로세스
2. 네비게이션 과정에서 일어나는 일
   - 네비게이션 과정에서 일어나는 일
   - 브라우저 프로세스에서 시작한다
   - 간단한 내비게이션
     - 입력처리, 내비게이션 시작, 응답 읽기, 렌더러 프로세스 찾기, 내비게이션 실행, 초기 로드 완료
   - 다른 사이트로 내비게이션
   - 서비스워커
   - 네비게이션 프리로드
3. 렌더러 프로세스의 내부 동작
   - 렌더러 프로세스의 내부 동작
   - 렌더러 프로세스는 웹 콘텐츠를 처리한다
   - 파싱
     - DOM 구축, 하위 리소스 로딩, 자바스크립트가 파싱을 막을 수 있다
   - 리소스를 어떻게 로딩하길 원하는지 브라우저에 힌트를 주는 방법
   - 스타일 계산
   - 레이아웃
   - 페인트
     - 렌더링 파이프라인을 갱신하는 데는 많은 비용이 든다
   - 합성
     - 합성이란
     - 여러 레이어로 나누기
     - 메인 스레드 이후 래스터화와 합성
4. 컴포지터가 사용자 입력을 받았을 때
   - 컴포지터가 사용자 입력을 받았을 때
   - 브라우저 관점에서 입력 이벤트
   - 컴포지터는 입력 이벤트를 받는다
   - 고속 스크롤 불가 영역의 이해
     - 이벤트 핸들러를 작성할 때 주의한다
   - 이벤트를 취소할 수 있는지 확인한다
   - 이벤트 대상 찾기
   - 메인 스레드로 이벤트를 전송하는 것을 최소화하기
   - 한 프레임 안에서 합쳐진 이벤트를 얻으려면 getCoalescedEvents() 메서드를 사용한다
   - 다음 단계
     - Lighthouse, 성능측정방법, 사이트에 기능 정책 추가
5. 브라우저 동작원리
   - 브라우저 주요 기능
   - 브라우저 기본 구조
   - 렌더링 엔진
     - 동작과정
     - 동작과정 예
     - 파싱과 DOM 트리 구축
       - 파싱 일반
       - 문법
       - 파서-어휘 분석기 조합
       - 변환
       - 파싱 예
       - 어휘와 구문에 대한 공식정의
       - 파서의 종류
       - 파서 자동 생성
     - HTML 파서
       - HTML 문법 정의
       - 문맥 자유 문법이 아님
       - HTML DTD
       - DOM
       - 파싱 알고리즘
       - 토큰화 알고리즘
       - 트리 구축 알고리즘
       - 파싱이 끝난 이후의 동작
       - 브라우저의 오류 처리
     - CSS 파싱
       - 웹킷 CSS 파서
     - 스크립트와 스타일시트 진행순서
     - 렌더 트리 구축
     - DOM 트리와 렌더 트리의 관계
     - 트리를 구축하는 과정
     - 스타일 계산
     - 다단계 순서에 따라 규칙 적용하기
     - 점진적 처리
     - 배치
       - 더티 비트 체제
       - 전역 배치와 점증 배치
       - 비동기 배치와 동기 배치
       - 최적화
       - 배치 과정
       - 너비 계산
       - 줄 바꿈
     - 그리기
       - 전역과 점증
       - 그리기 순서
     - 동적 변경
     - 렌더링 엔진의 스레드
     - CSS2 시각 모델
       - 캔버스
       - CSS 박스 모델
       - 위치 결정 방법
       - 박스 유형
       - 위치 잡기

---

## 1. CPU,GPU,메모리, 다중 프로세스 아키텍처

- **CPU**
  - CPU(중앙처리장치, central processing unit)
  - 컴퓨터의 두뇌
  - CPU 코어는 여러 종류의 작업을 하나씩 순서대로 처리할 수 있음
  - 최신 하드웨어는 보통 하나 이상의 코어를 사용해 실행성능을 높임
- **GPU**
  - GPU(그래픽처리장치, graphics processing unit)
  - 간단한 작업에 특화되어 잇으며 여러 GPU 코어가 동시에 작업을 수행할 수 있음
  - GPU가속을 통해 GPU가 단독으로 처리할 수 있는 계산이 더 많아짐
  - 하드웨어 가속 : 특정 작업을 CPU가 아닌 다른 특별한 장치를 통해 수행 속도를 높이는 것, 그래픽과 사운드 관련 작업에 하드웨어 가속을 많이 사용함. 브라우저에서 하드웨어 가속은 주로 GPU를 사용한 그래픽 작업의 가속을 의미한다.
  - 컴퓨터 아키텍처 세가지 층위 : 하드웨어-운영체제-애플리케이션
- **Process & Thread**
  - Process : 애플리케이션이 실행하는 프로그램
  - Thread : 프로세스 내부에 있으며 프로세스로 실행되는 프로그램 일부를 실행
  - 애플리케이션 실행 시 프로세스가 하나 만들어지며 작업을 위해 스레드를 생성할 수 있으나 선택사항
  - 운영체제는 프로세스가 작업할 메모리 공간을 주고 이 전용 공간에 애플리케이션의 모든 상태가 저장된다. 애플리케이션을 닫으면 프로세스가 사라지고 운영체제가 메모리를 비운다
  - 프로세스는 여러 작업을 수행하기 위해 운영체제에 다른 프로세스를 실행하라고 요청할 수 있다. 그러면 메모리의 다른 부분이 새프로세스에 할당되며 프로세스간 정보 공유는 IPC를 사용
- **Browser Architecture**
  - 스레드를 많이 사용하는 프로세스 하나만 사용하거나 스레드를 조금만 사용하는 프로세스를 여러개 만들어 IPC로 통신할 수도 있다.
  - Chrome의 최근 아키텍처
    - 제일 위에 있는 브라우저 프로세스는 애플리케이션의 각 부분을 맡고 있는 다른 프로세스를 조정한다.
    - 렌더러 프로세스는 여러개가 만들어져 각 탭마다 할당된다
    - 최근까지 Chrome은 탭마다 프로세스를 할당했으나 이제는 사이트(iframe에 있는 사이트포함)마다 프로세스를 할당한다
  - 프로세스 할당 방법
    - process per tab : 탭마다 프로세스를 할당하는 방법
    - process per site : 사이트마다 프로세스를 할당하는 방법
    - chrome://flags/#enable-site-per-process 설정에서 할당방법변경
- **Chrome의 각 Process**
  - 브라우저 프로세스 : 주소 표시줄, 북마크 막대, 뒤로가기 버튼, 앞으로 가기 버튼 등 애플리케이션의 chrome 부분(브라우저의 UI영역)을 제어. 네트워크 요청이나 파일 접근과 같이 눈에 보이지는 않으나 권한이 필요한 부분도 처리.
  - 렌더러 프로세스 : 탭 안에서 웹사이트가 표시되는 부분의 모든 것을 제어.
  - 플러그인 프로세스 : 웹 사이트에서 사용하는 플러그인을 제어.
  - GPU 프로세스 : GPU 작업을 다른 프로세스와 격리해서 처리. GPU는 여러 애플리케이션 요청을 처리하고 같은 화면에 요청받은 내용을 그리기 때문에 GPU 프로세스는 별도 프로세스로 분리되어 있다.
  - Chrome 실행 프로세스 확인 : Chrome 맞춤설정 및 제어 -> 도구 더보기 -> 작업 관리자 (실행 프로세스 목록, CPU, 메모리)
- **다중 프로세스 아키텍처가 Chrome에 주는 이점**
- **Chrome의 서비스화 - 메모리 절약**
- **사이트 격리 - 프레임별로 실행되는 렌더러 프로세스**

## 2. 네비게이션 과정에서 일어나는 일

- **네비게이션 과정에서 일어나는 일**
- **브라우저 프로세스에서 시작한다**
- **간단한 내비게이션**
- **입력처리, 내비게이션 시작, 응답 읽기, 렌더러 프로세스 찾기, 내비게이션 실행, 초기 로드 완료**
- **다른 사이트로 내비게이션**
- **서비스워커**
- **네비게이션 프리로드**

## 3. 렌더러 프로세스의 내부 동작

- **렌더러 프로세스의 내부 동작**
- **렌더러 프로세스는 웹 콘텐츠를 처리한다**
- **파싱**
- **DOM 구축, 하위 리소스 로딩, 자바스크립트가 파싱을 막을 수 있다**
- **리소스를 어떻게 로딩하길 원하는지 브라우저에 힌트를 주는 방법**
- **스타일 계산**
- **레이아웃**
- **페인트**
- **렌더링 파이프라인을 갱신하는 데는 많은 비용이 든다**
- **합성**
- **합성이란**
- **여러 레이어로 나누기**
- **메인 스레드 이후 래스터화와 합성**

## 4. 컴포지터가 사용자 입력을 받았을 때

- **컴포지터가 사용자 입력을 받았을 때**
- **브라우저 관점에서 입력 이벤트**
- **컴포지터는 입력 이벤트를 받는다**
- **고속 스크롤 불가 영역의 이해**
- **이벤트 핸들러를 작성할 때 주의한다**
- **이벤트를 취소할 수 있는지 확인한다**
- **이벤트 대상 찾기**
- **메인 스레드로 이벤트를 전송하는 것을 최소화하기**
- **한 프레임 안에서 합쳐진 이벤트를 얻으려면 getCoalescedEvents() 메서드를 사용한다**
- **다음 단계**
  - Lighthouse, 성능측정방법, 사이트에 기능 정책 추가
